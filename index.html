<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Confluence → Markdown Converter</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #f7f7f7;
    }
    h1 {
      font-size: 1.1rem;
      margin: 0;
    }
    .tabs {
      display: flex;
      gap: 0.5rem;
    }
    .tab {
      border: none;
      background: transparent;
      padding: 0.35rem 0.75rem;
      cursor: pointer;
      border-radius: 999px;
      font-size: 0.9rem;
    }
    .tab.active {
      background: #0052cc;
      color: white;
    }
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .panel {
      flex: 1;
      display: none;
      height: 100%;
    }
    .panel.active {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .convert-shell {
      flex: 1;
      display: flex;
      height: 100%;
      overflow: hidden;
    }
    .pane-left {
      width: 260px;
      min-width: 220px;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      border-right: 1px solid #ddd;
      box-sizing: border-box;
    }
    .pane-right {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
    }
    .resizer {
      width: 5px;
      cursor: col-resize;
      background: #e0e0e0;
      flex-shrink: 0;
    }
    .resizer:hover {
      background: #c5c5c5;
    }

    .pane-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0.75rem;
      box-sizing: border-box;
      min-height: 0;
    }
    .box {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .box + .box {
      margin-top: 0.75rem;
    }
    .box label {
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
    .box small {
      font-size: 0.75rem;
      color: #555;
    }

    #pasteArea {
      flex: 1;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 0.5rem;
      overflow: auto;
      background: #fff;
    }
    textarea {
      flex: 1;
      resize: none;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 0.5rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
      box-sizing: border-box;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.25rem;
      align-items: center;
    }
    button.primary {
      background: #0052cc;
      color: white;
      border-radius: 4px;
      padding: 0.25rem 0.6rem;
      border: none;
      cursor: pointer;
      font-size: 0.8rem;
    }
    button.secondary {
      background: #f0f0f0;
      color: #333;
      border-radius: 4px;
      padding: 0.25rem 0.6rem;
      border: 1px solid #ccc;
      cursor: pointer;
      font-size: 0.8rem;
    }
    button.primary:hover {
      background: #0747a6;
    }
    button.secondary:hover {
      background: #e4e4e4;
    }
    #status {
      font-size: 0.75rem;
      color: #555;
    }
    #rulesArea {
      width: 100%;
      height: 100%;
    }
    .option-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      font-size: 0.75rem;
      align-items: center;
    }
    .option-group label {
      font-weight: 400;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      cursor: pointer;
    }
  </style>
  <script src="https://unpkg.com/turndown/dist/turndown.js"></script>
  <script src="https://unpkg.com/turndown-plugin-gfm/dist/turndown-plugin-gfm.js"></script>
</head>
<body>
  <header>
    <h1>Confluence → Markdown Converter</h1>
    <div class="tabs">
      <button class="tab active" data-tab="convert">Convert</button>
      <button class="tab" data-tab="settings">Settings</button>
    </div>
  </header>

  <main>
    <!-- Convert -->
    <section class="panel active" id="panel-convert">
      <div class="convert-shell">
        <div class="pane-left" id="paneLeft">
          <div class="pane-section">
            <div class="box" style="flex: 1;">
              <label for="pasteArea">1. Paste from Confluence here</label>
              <small>Click, then Ctrl+V. Uses HTML on the clipboard.</small>
              <div id="pasteArea" contenteditable="true"></div>
              <div class="controls">
                <button class="secondary" id="clearPaste">Clear</button>
                <span id="status"></span>
              </div>
            </div>
            <div class="box" style="flex: 1; margin-top: 0.75rem;">
              <label for="htmlView">2. Raw HTML (debug)</label>
              <small>What Confluence actually put on the clipboard.</small>
              <textarea id="htmlView" spellcheck="false"></textarea>
            </div>
          </div>
        </div>

        <div class="resizer" id="resizer"></div>

        <div class="pane-right">
          <div class="pane-section" style="flex: 3;">
            <div class="box" style="flex: 1;">
              <label for="markdownView">3. Markdown output</label>
              <small>Copy this into ChatGPT / your editor.</small>
              <textarea id="markdownView" spellcheck="false"></textarea>
              <div class="controls">
                <button class="primary" id="copyMarkdown">Copy Markdown</button>
                <div class="option-group">
                  <label>
                    <input type="checkbox" id="includeLinks" checked />
                    Include links
                  </label>
                  <label>
                    <input type="checkbox" id="includeImagePlaceholders" checked />
                    Image placeholders
                  </label>
                  <label>
                    <input type="checkbox" id="emojiNames" />
                    Emoji names
                  </label>
                </div>
              </div>
            </div>
          </div>
          <div class="pane-section" style="flex: 1; border-top: 1px solid #eee;">
            <div class="box">
              <label>Notes</label>
              <small>
                If something looks wrong, describe it to ChatGPT and update the
                rules on the Settings tab. Then paste again.
              </small>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Settings -->
    <section class="panel" id="panel-settings">
  <div style="flex: 1; display: flex; flex-direction: column; padding: 0.75rem; box-sizing: border-box; overflow: hidden;">
    <div class="box" style="flex: 0 0 auto;">
      <label for="rulesArea">Rules JSON</label>
      <small>
        Edit rules and click <strong>Save rules</strong>. Rules are stored in your
        browser (localStorage) and you can export/import them as a file.
      </small>
      <div class="controls">
        <button class="primary" id="saveRules" type="button">Save rules</button>
        <button class="secondary" id="resetRules" type="button">Reset to defaults</button>
        <button class="secondary" id="exportRules" type="button">Export rules</button>
        <button class="secondary" id="importRules" type="button">Import rules</button>
        <span id="rulesStatus"></span>
      </div>
      <!-- hidden file input for import -->
      <input type="file" id="rulesFileInput" accept="application/json,.json" style="display:none;">
    </div>
    <div class="box" style="flex: 1 1 auto; margin-top: 0.75rem; min-height: 0;">
      <textarea id="rulesArea" spellcheck="false" style="width: 100%; height: 100%;"></textarea>
    </div>
  </div>
</section>


  </main>

  <script>
    const DEFAULT_RULES = {
      htmlPreprocessors: [
        {
          description: "Unwrap <mark> annotation tags",
          pattern: "<mark[^>]*>([\\s\\S]*?)<\\/mark>",
          replacement: "$1",
          flags: "gi"
        },
        {
          description: "Remove Confluence heading anchor buttons",
          pattern:
            "<span[^>]*class=\"heading-anchor-wrapper\"[\\s\\S]*?<\\/span>",
          replacement: "",
          flags: "gi"
        },
        {
          description: "Strip table colgroup definitions",
          pattern: "<colgroup[\\s\\S]*?<\\/colgroup>",
          replacement: "",
          flags: "gi"
        },
        {
          description: "Remove Confluence table sorting icons",
          pattern:
            "<figure[^>]*class=\"ak-renderer-tableHeader-sorting-icon__wrapper\"[\\s\\S]*?<\\/figure>",
          replacement: "",
          flags: "gi"
        }
      ],
      markdownPostprocessors: [
        {
          description: "Fix '# - ' heading-list hybrids",
          pattern: "^# - ",
          replacement: "- ",
          flags: "gm"
        },
        {
          description: "Split combined heading + table header row (e.g. '# Title | ...')",
          pattern: "^# ([^|\\n]+)\\s*\\|\\s*(.+)$",
          replacement: "# $1\n\n| $2",
          flags: "gm"
        }
      ]
    };

    const STORAGE_KEY = "confluenceMdRules";

    function loadRules() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return structuredClone(DEFAULT_RULES);
      try {
        const parsed = JSON.parse(raw);
        if (
          typeof parsed === "object" &&
          parsed.htmlPreprocessors &&
          parsed.markdownPostprocessors
        ) {
          return parsed;
        }
        return structuredClone(DEFAULT_RULES);
      } catch {
        return structuredClone(DEFAULT_RULES);
      }
    }

    function saveRulesToStorage(rules) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(rules, null, 2));
    }

    const pasteArea = document.getElementById("pasteArea");
    const htmlView = document.getElementById("htmlView");
    const markdownView = document.getElementById("markdownView");
    const statusEl = document.getElementById("status");
    const rulesArea = document.getElementById("rulesArea");
    const rulesStatus = document.getElementById("rulesStatus");

    const saveRulesBtn = document.getElementById("saveRules");
    const resetRulesBtn = document.getElementById("resetRules");
    const clearPasteBtn = document.getElementById("clearPaste");
    const copyMarkdownBtn = document.getElementById("copyMarkdown");

    const exportRulesBtn = document.getElementById("exportRules");
    const importRulesBtn = document.getElementById("importRules");
    const rulesFileInput = document.getElementById("rulesFileInput");

    const includeLinksInput = document.getElementById("includeLinks");
    const includeImagePlaceholdersInput =
      document.getElementById("includeImagePlaceholders");
    const emojiNamesInput = document.getElementById("emojiNames");

    const tabButtons = document.querySelectorAll(".tab");
    const panels = {
      convert: document.getElementById("panel-convert"),
      settings: document.getElementById("panel-settings")
    };

    const paneLeft = document.getElementById("paneLeft");
    const resizer = document.getElementById("resizer");

    const turndownService = new TurndownService({
      headingStyle: "atx",
      bulletListMarker: "-",
      codeBlockStyle: "fenced"
    });
    if (window.turndownPluginGfm) {
      turndownService.use(turndownPluginGfm.gfm);
    }

    let currentOptions = {
      includeLinks: true,
      includeImagePlaceholders: true,
      emojiNames: false
    };

    // Custom table rule: normalise Confluence tables to clean GFM tables
turndownService.addRule("confluenceTable", {
  filter: "table",
  replacement: function (content, node) {
    // Use a separate Turndown instance for cell contents
    const cellTd = new TurndownService({
      headingStyle: "atx",
      bulletListMarker: "-",
      codeBlockStyle: "fenced"
    });

    // Convert a single TH/TD cell to one-line markdown
    function cellMarkdown(cell) {
      const html = cell.innerHTML || "";
      let md = cellTd.turndown(html);

      // Collapse list items and paragraphs into a single line
      md = md
        .replace(/\r/g, "")
        .replace(/\n{2,}/g, "\n")
        .replace(/\n- /g, "<br>• ")    // preserve bullet items with visible markers
        .replace(/\n/g, "<br>")        // preserve line breaks safely using <br>
        .replace(/\s+/g, " ")
        .trim();


      return md || " ";
    }

    const rows = Array.from(node.querySelectorAll("tr"));
    if (!rows.length) return "";

    // Find header row: first row that has a TH, otherwise first row
    let headerRowIndex = rows.findIndex((row) =>
      Array.from(row.children).some((c) => c.tagName === "TH")
    );
    if (headerRowIndex === -1) headerRowIndex = 0;

    const headerRow = rows[headerRowIndex];
    const headerCells = Array.from(headerRow.children)
      .filter((c) => c.tagName === "TH" || c.tagName === "TD")
      .map(cellMarkdown);

    if (!headerCells.length) return "";

    const colCount = headerCells.length;

    const lines = [];

    // Header line
    lines.push("| " + headerCells.join(" | ") + " |");

    // Separator line
    const sep = Array(colCount).fill("---");
    lines.push("| " + sep.join(" | ") + " |");

    // Data rows
    rows.forEach((row, idx) => {
      if (idx === headerRowIndex) return; // skip header row

      const cells = Array.from(row.children)
        .filter((c) => c.tagName === "TH" || c.tagName === "TD")
        .map(cellMarkdown);

      // Pad or truncate to header column count
      while (cells.length < colCount) cells.push("");
      if (cells.length > colCount) cells.length = colCount;

      lines.push("| " + cells.join(" | ") + " |");
    });

    // Surround table with blank lines so it doesn't glue to paragraphs/headings
    return "\n\n" + lines.join("\n") + "\n\n";
  }
});


    turndownService.addRule("imagePlaceholder", {
      filter: "img",
      replacement: function (content, node) {
        const opts = currentOptions || {};
        const alt = node.getAttribute("alt") || "";
        const src = node.getAttribute("src") || "";
        const emojiShort = node.getAttribute("data-emoji-short-name") || "";

        let isEmoji = false;
        try {
          if (alt) {
            isEmoji =
              /\p{Extended_Pictographic}/u.test(alt) || alt.length <= 3;
          }
        } catch (e) {
          isEmoji = alt && alt.length <= 3;
        }
        if (!isEmoji && emojiShort) {
          isEmoji = true;
        }

        if (isEmoji) {
          if (!opts.emojiNames) return "";
          const name = emojiShort || alt || "emoji";
          return `:${name}:`;
        }

        if (!opts.includeImagePlaceholders) return "";

        let filename = "";
        if (src) {
          try {
            const url = new URL(src, window.location.href);
            const parts = url.pathname.split("/");
            filename = parts[parts.length - 1] || "";
          } catch (e) {
            filename = src.split("/").pop() || "";
          }
        }
        const label = filename || alt || "Image";
        return `[Image: ${label}]`;
      }
    });

    function applyRegexRules(text, rules = []) {
      let out = text;
      for (const r of rules) {
        try {
          const re = new RegExp(r.pattern, r.flags || "g");
          out = out.replace(re, r.replacement);
        } catch (err) {
          console.error("Bad rule", r, err);
        }
      }
      return out;
    }

    function convertHtmlToMarkdown(html, rules, options) {
      if (!html) return "";
      currentOptions = { ...currentOptions, ...options };

      const preprocessed = applyRegexRules(
        html,
        rules.htmlPreprocessors || []
      );

      let md = "";
      try {
        md = turndownService.turndown(preprocessed);
      } catch (err) {
        console.error("Turndown error:", err);
        md = "Error converting HTML to Markdown:\n" + err;
      }

      md = applyRegexRules(md, rules.markdownPostprocessors || []);

      if (!options.includeLinks) {
        md = md.replace(
          /!\[[^\]]*\]\([^)]+\)|\[[^\]]+\]\([^)]+\)/g,
          (match) => {
            if (match.startsWith("!")) return match;
            return match.replace(/^\[([^\]]+)\]\([^)]+\)$/, "$1");
          }
        );
      }

      return md.trim() + "\n";
    }

    let currentRules = loadRules();
    rulesArea.value = JSON.stringify(currentRules, null, 2);

    let lastHtml = "";

    function recomputeFromCurrent() {
      if (!lastHtml) return;
      const options = {
        includeLinks: includeLinksInput.checked,
        includeImagePlaceholders: includeImagePlaceholdersInput.checked,
        emojiNames: emojiNamesInput.checked
      };
      const md = convertHtmlToMarkdown(lastHtml, currentRules, options);
      markdownView.value = md;
    }

    pasteArea.addEventListener("paste", (e) => {
      e.preventDefault();
      statusEl.textContent = "";

      const html = e.clipboardData.getData("text/html");
      const plain = e.clipboardData.getData("text/plain");

      if (!html && !plain) {
        statusEl.textContent = "No HTML/plain text on clipboard.";
        return;
      }

      const source = html || plain;
      lastHtml = source;

      pasteArea.innerHTML = html || plain;
      htmlView.value = html || "<!-- no text/html on clipboard -->\n" + plain;

      recomputeFromCurrent();
      statusEl.textContent = "Converted from clipboard HTML.";
    });

    clearPasteBtn.addEventListener("click", () => {
      pasteArea.innerHTML = "";
      htmlView.value = "";
      markdownView.value = "";
      lastHtml = "";
      statusEl.textContent = "Cleared.";
    });

    copyMarkdownBtn.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(markdownView.value);
        statusEl.textContent = "Markdown copied to clipboard.";
      } catch (err) {
        statusEl.textContent = "Could not copy markdown.";
      }
    });

    includeLinksInput.addEventListener("change", recomputeFromCurrent);
    includeImagePlaceholdersInput.addEventListener("change", recomputeFromCurrent);
    emojiNamesInput.addEventListener("change", recomputeFromCurrent);

    saveRulesBtn.addEventListener("click", () => {
      try {
        const parsed = JSON.parse(rulesArea.value);
        currentRules = parsed;
        saveRulesToStorage(parsed);
        rulesStatus.textContent = "Rules saved.";
        setTimeout(() => (rulesStatus.textContent = ""), 1500);
        recomputeFromCurrent();
      } catch (err) {
        rulesStatus.textContent = "Invalid JSON: " + err;
      }
    });

    resetRulesBtn.addEventListener("click", () => {
      currentRules = structuredClone(DEFAULT_RULES);
      rulesArea.value = JSON.stringify(currentRules, null, 2);
      saveRulesToStorage(currentRules);
      rulesStatus.textContent = "Defaults restored.";
      setTimeout(() => (rulesStatus.textContent = ""), 1500);
      recomputeFromCurrent();
    });

    // EXPORT RULES TO FILE
    exportRulesBtn.addEventListener("click", () => {
      try {
        const parsed = JSON.parse(rulesArea.value);
        const pretty = JSON.stringify(parsed, null, 2);

        const blob = new Blob([pretty], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        a.href = url;
        a.download = `confluence-md-rules-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        rulesStatus.textContent = "Rules exported.";
        setTimeout(() => (rulesStatus.textContent = ""), 1500);
      } catch (err) {
        console.error(err);
        rulesStatus.textContent = "Cannot export: rules JSON is invalid.";
        setTimeout(() => (rulesStatus.textContent = ""), 2500);
      }
    });

    // IMPORT RULES FROM FILE
    importRulesBtn.addEventListener("click", () => {
      rulesFileInput.value = "";
      rulesFileInput.click();
    });

    rulesFileInput.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = () => {
        try {
          const text = String(reader.result || "");
          const parsed = JSON.parse(text);
          const pretty = JSON.stringify(parsed, null, 2);

          currentRules = parsed;
          rulesArea.value = pretty;
          saveRulesToStorage(currentRules);
          rulesStatus.textContent = `Rules imported from "${file.name}".`;
          setTimeout(() => (rulesStatus.textContent = ""), 2000);

          recomputeFromCurrent();
        } catch (err) {
          console.error(err);
          rulesStatus.textContent =
            "Import failed: file does not contain valid rules JSON.";
          setTimeout(() => (rulesStatus.textContent = ""), 2500);
        }
      };
      reader.readAsText(file);
    });

    tabButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const target = btn.dataset.tab;
        tabButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        Object.entries(panels).forEach(([name, el]) => {
          el.classList.toggle("active", name === target);
        });
      });
    });

    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    resizer.addEventListener("mousedown", (e) => {
      isResizing = true;
      startX = e.clientX;
      startWidth = paneLeft.getBoundingClientRect().width;
      document.body.style.cursor = "col-resize";
      e.preventDefault();
    });

    window.addEventListener("mousemove", (e) => {
      if (!isResizing) return;
      const dx = e.clientX - startX;
      let newWidth = startWidth + dx;
      if (newWidth < 220) newWidth = 220;
      if (newWidth > 600) newWidth = 600;
      paneLeft.style.width = newWidth + "px";
    });

    window.addEventListener("mouseup", () => {
      if (!isResizing) return;
      isResizing = false;
      document.body.style.cursor = "";
    });
  </script>
</body>
</html>
